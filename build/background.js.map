{"version":3,"file":"background.js","mappings":";;;;;;;;;;;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO,mCAAmC;AAC1C;AACA,qDAAqD,2BAA2B;AAChF;;AAEO;AACP;AACA;;;;;;UCrCA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;ACNwE;;AAExE,8CAA8C,EAAE;;;AAGhD,0CAA0C;AAC1C,+BAA+B,mCAAmC;AAClE,iCAAiC,gCAAgC;AACjE,CAAC;;;AAGD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA,gDAAgD,mCAAmC;AACnF;AACA;AACA;AACA,2BAA2B,IAAI;AAC/B;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,wBAAwB,mCAAmC;AAC3D;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,sD","sources":["webpack://akizuki-chrome-ext/./src/abortableFetch.js","webpack://akizuki-chrome-ext/webpack/bootstrap","webpack://akizuki-chrome-ext/webpack/runtime/define property getters","webpack://akizuki-chrome-ext/webpack/runtime/hasOwnProperty shorthand","webpack://akizuki-chrome-ext/webpack/runtime/make namespace object","webpack://akizuki-chrome-ext/./src/background.js"],"sourcesContent":["\nconst AbortableFetchObject = class {\n    constructor(_con, _fetch) {\n        this._con = _con;\n        this._fetch = _fetch;\n        this._status = null;\n        _fetch.then(r => {\n            this._status = r.status\n        })\n    }\n    abort() {\n        this._con.abort();\n    }\n    get status() {\n        return this._status;\n    }\n    async _request() {\n        return (await this._fetch).clone();\n    }\n    async valid() {\n        await this._fetch;\n        return this;\n    }\n}\nfor(const m of ['text', 'json', 'blob', 'arrayBuffer', 'formData']) {\n    AbortableFetchObject.prototype[m] = async function() {\n        return await (await this._request())[m]();\n    };\n};\n\nexport const abortableFetch = (url, opt={}) => {\n    const con = new AbortController();\n    return new AbortableFetchObject(con, fetch(url, {...opt, signal: con.signal}));\n};\n\nexport const abortableFetchList = async (...af) => {\n    return await Promise.all(af.map(f => f._request()));\n};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { abortableFetch, abortableFetchList } from './abortableFetch.js'\n\nconst idreg = /\\/catalog\\/g\\/g([MKPBRSICT]-\\d{5})\\//;\n\n\nchrome.runtime.onInstalled.addListener(({}) => {\n    chrome.storage.local.set({ ['__akizuki_current_item_id']: '' });\n    //chrome.storage.local.set({ ['__akizuki_my_item_list']: [] });\n});\n\n\nchrome.contextMenus.create({\n    id: '__akizuki_right_click',\n    title: 'リンク先を買い物リストに追加する',\n    contexts: ['link'],\n}, () => chrome.runtime.lastError);\nchrome.contextMenus.onClicked.addListener(async item => {\n    console.log(item);\n    if(item.menuItemId == '__akizuki_right_click') {\n\n        const id = item.linkUrl.match(idreg)?.[1];\n        if(!id) return null;\n        const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });\n        chrome.tabs.sendMessage(tab.id,\n            {\n                name: 'add_item',\n                payload: { id },\n            }\n          );\n    }\n});\n\nconst callback = x => {\n    chrome.tabs.get(x?.tabId || x, tab => {\n        const { url } = tab;\n        const _id = url.match(idreg)?.[1];\n        chrome.storage.local.set({\n            '__akizuki_current_item_id': _id || ''\n        });\n    })\n    /*\n    chrome.tabs.query({ active: true, currentWindow: true }, tab => {\n        if(!tab.length) return;\n    });\n    */\n};\n\nchrome.tabs.onActivated.addListener(callback);\nchrome.tabs.onUpdated.addListener(callback);\n//chrome.windows.onFocusChanged.addListener(callback);"],"names":[],"sourceRoot":""}